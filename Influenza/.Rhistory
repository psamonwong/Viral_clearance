initial_state <- c(QL = 5.6e06,
FL = 10000,
I = 40000,
A = 200,
R = 300)
# Parameters
parameters <- c(r = 1/120 * 1/2000,
p = 0.5,
b = 200,
sigma = 1/20,
gamma = 1/180,
mu_q = 1/300,
mu_f = 1/5,
mu_i = 1/100,
mu_a = 1,
mu_r = 1/100,
b_r = 1/90 * 6 ,
K = 50,
K_r = 400,
omega = (2*pi)/(365),
amplitude = 0.03,
phi = 100)
# Time vector
time <- seq(0, 5*365, by = 1)
# Solve the differential equations
output <- ode(y = initial_state, times = time, func = model, parms = parameters, br_seasonal = br_seasonal)
# Plotting the results
plot(output)
# Parameters
parameters <- c(r = 1/120 * 1/2000,
p = 0.5,
b = 200,
sigma = 1/20,
gamma = 1/180,
mu_q = 1/300,
mu_f = 1/5,
mu_i = 1/100,
mu_a = 1,
mu_r = 1/100,
b_r = 1/90 * 6 ,
K = 50,
K_r = 400,
omega = (2*pi)/(365),
amplitude = 0.03,
phi = 0)
# Time vector
time <- seq(0, 5*365, by = 1)
# Solve the differential equations
output <- ode(y = initial_state, times = time, func = model, parms = parameters, br_seasonal = br_seasonal)
# Plotting the results
plot(output)
plot(time, unlist(output)[,"FL"]/unlist(output)[,"R"], type = "l")
# Load the odin package
library(odin)
1/0.003
#install.packages("odin")
################################################################################
# Load the odin package
library(odin)
# Model 1 from Kim 2010
# Mite-host dynamics without infections
model <- odin::odin({
# The ODEs
deriv(LQ) <- a * A - d_L * LQ - beta * H * LQ # questing larvae
deriv(LF) <- beta * H * LQ - sigma * LF # feeding larvae
deriv(A) <- m * sigma * LF - d_A * A # adults
deriv(H) <- (b - d_H) * H # Host dynamics
a <- r * exp(-s * M) #birth rate as a function of population size
# Total population
M <- LQ + LF + A
# Parameters
r <- 30 # average offspring
s <- 0.0075 # s > 0 density-dependent regulation
d_L <- 0.0056 # mortality rate of larvae
beta <- 0.015 # encounter rate between questing larvae and hosts
sigma <- 0.1 # dropping rate
m <- 0.15 # averaged fraction of immature feeding mites which survies and develops to the next stage
d_A <- 0.006 # mortality rate of adults
b <- 0.003 # birth rate of hosts
d_H <- 0.003 # death rate of hosts
# Initial conditions
initial(LQ) <- 0
initial(LF) <- 0
initial(A) <- 1
initial(H) <- 20
})
# Generate the model
mod <- model()
# Model 1 from Kim 2010
# Mite-host dynamics without infections
model <- odin::odin({
# The ODEs
deriv(LQ) <- a * A - d_L * LQ - beta * H * LQ # questing larvae
deriv(LF) <- beta * H * LQ - sigma * LF # feeding larvae
deriv(A) <- m * sigma * LF - d_A * A # adults
deriv(H) <- (b - d_H) * H # Host dynamics
a <- r * exp(-s * M) #birth rate as a function of population size
# Total population
M <- LQ + LF + A
# Parameters
r <- 30 # average offspring
s <- 0.0075 # s > 0 density-dependent regulation
d_L <- 0.0056 # mortality rate of larvae
beta <- 0.015 # encounter rate between questing larvae and hosts
sigma <- 0.1 # dropping rate
m <- 0.15 # averaged fraction of immature feeding mites which survies and develops to the next stage
d_A <- 0.006 # mortality rate of adults
b <- 0.003 # birth rate of hosts
d_H <- 0.003 # death rate of hosts
# Initial conditions
initial(LQ) <- 0
initial(LF) <- 0
initial(A) <- 1
initial(H) <- 20
})
# Generate the model
mod <- model()
# Model 1 from Kim 2010
# Mite-host dynamics without infections
pop_model <- odin::odin({
# The ODEs
deriv(LQ) <- a * A - d_L * LQ - beta * H * LQ # questing larvae
deriv(LF) <- beta * H * LQ - sigma * LF # feeding larvae
deriv(A) <- m * sigma * LF - d_A * A # adults
deriv(H) <- (b - d_H) * H # Host dynamics
a <- r * exp(-s * M) #birth rate as a function of population size
# Total population
M <- LQ + LF + A
# Parameters
r <- 30 # average offspring
s <- 0.0075 # s > 0 density-dependent regulation
d_L <- 0.0056 # mortality rate of larvae
beta <- 0.015 # encounter rate between questing larvae and hosts
sigma <- 0.1 # dropping rate
m <- 0.15 # averaged fraction of immature feeding mites which survies and develops to the next stage
d_A <- 0.006 # mortality rate of adults
b <- 0.003 # birth rate of hosts
d_H <- 0.003 # death rate of hosts
# Initial conditions
initial(LQ) <- 0
initial(LF) <- 0
initial(A) <- 1
initial(H) <- 20
})
# Generate the model
mod <- pop_model()
# Generate the model
mod <- pop_model$new()
# Time points to solve the model at
times <- seq(0, 160, by = 1)
# Time points to solve the model at
times <- seq(0, 500, by = 1)
# Initial state
yini <- c(LQ = 0, LF = 0, A = 1, H = 20)
# Solve the model
result <- mod$run(times, yini)
################################################################################
as.data.frame(result)
library(dplyr)
# Solve the model
result <- mod$run(times, yini) %>% as.data.frame()
library(ggplot2)
ggplot(result, aes(x = t, y = LQ)) +
geom_line()
ggplot(result, aes(x = t)) +
geom_line(aes(y = LQ))
ggplot(result, aes(x = t)) +
geom_line(aes(y = LQ)) +
geom_line(aes(y = A))
ggplot(result, aes(x = t)) +
geom_line(aes(y = LQ)) +
geom_line(aes(y = A), col = "red")
library(tidyr)
result %>%
pivot_longer(!t, names_to = "stage", values_to = "values")
result %>%
pivot_longer(!t, names_to = "stage", values_to = "values") %>%
as.data.frame()
result %>%
pivot_longer(!t, names_to = "stage", values_to = "values") %>%
arrange(stage) %>%
as.data.frame()
result %>%
pivot_longer(!t, names_to = "stage", values_to = "values") %>%
arrange(stage, t) %>%
as.data.frame()
result <- result %>%
pivot_longer(!t, names_to = "stage", values_to = "values") %>%
arrange(stage, t) %>%
as.data.frame()
ggplot(result[result$stage != "H",], aes(x = t, y = value, col = stage)) +
theme_bw()
ggplot(result[result$stage != "H",], aes(x = t, y = values, col = stage)) +
theme_bw()
ggplot(result[result$stage != "H",], aes(x = t, y = values, col = stage)) +
geom_line() +
theme_bw()
################################################################################
a <- 30 * exp(-0.0075 * 1:100)
plot(1:100, a, type = "l")
################################################################################
a <- 30 * exp(-0.0075 * 1:1000)
plot(1:1000, a, type = "l")
# Solve the model
result <- mod$run(times, yini,
d_H = 0.001) %>% as.data.frame()
result <- result %>%
pivot_longer(!t, names_to = "stage", values_to = "values") %>%
arrange(stage, t) %>%
as.data.frame()
################################################################################
ggplot(result[result$stage != "H",], aes(x = t, y = values, col = stage)) +
geom_line() +
theme_bw()
# Solve the model
result <- mod$run(times, yini,
d_H = 0.001) %>% as.data.frame()
result
# Solve the model
result <- mod$run(times, yini,
d_H = 0.001) %>% as.data.frame()
result <- result %>%
pivot_longer(!t, names_to = "stage", values_to = "values") %>%
arrange(stage, t) %>%
as.data.frame()
################################################################################
ggplot(result[result$stage != "H",], aes(x = t, y = values, col = stage)) +
geom_line() +
theme_bw()
# Solve the model
result <- mod$run(times, yini,
d_H = 0.00001) %>% as.data.frame()
#install.packages("odin")
################################################################################
# Load the odin package
library(odin)
library(dplyr)
library(ggplot2)
library(tidyr)
################################################################################
# Define the model using odin
# Model 1 from Kim 2010
# Mite-host dynamics without infections
pop_model <- odin::odin({
# The ODEs
deriv(LQ) <- a * A - d_L * LQ - beta * H * LQ # questing larvae
deriv(LF) <- beta * H * LQ - sigma * LF # feeding larvae
deriv(A) <- m * sigma * LF - d_A * A # adults
deriv(H) <- (b - d_H) * H # Host dynamics
a <- r * exp(-s * M) #birth rate as a function of population size
# Total population
M <- LQ + LF + A
# Parameters
r <- user(30) # average offspring
s <- user(0.0075) # s > 0 density-dependent regulation
d_L <- user(0.0056) # mortality rate of larvae
beta <- user(0.015) # encounter rate between questing larvae and hosts
sigma <- user(0.1) # dropping rate
m <- user(0.15) # averaged fraction of immature feeding mites which survies and develops to the next stage
d_A <- user(0.006) # mortality rate of adults
b <- user(0.003) # birth rate of hosts
d_H <- user(0.003) # death rate of hosts
# Initial conditions
initial(LQ) <- 0
initial(LF) <- 0
initial(A) <- 1
initial(H) <- 20
})
################################################################################
# Generate the model
mod <- pop_model$new()
# Time points to solve the model at
times <- seq(0, 500, by = 1)
# Initial state
yini <- c(LQ = 0, LF = 0, A = 1, H = 20)
# Solve the model
result <- mod$run(times, yini,
d_H = 0.00001) %>% as.data.frame()
result <- result %>%
pivot_longer(!t, names_to = "stage", values_to = "values") %>%
arrange(stage, t) %>%
as.data.frame()
result
################################################################################
ggplot(result[result$stage != "H",], aes(x = t, y = values, col = stage)) +
geom_line() +
theme_bw()
# Generate the model
mod <- pop_model$new(d_H = 0.001)
# Solve the model
result <- mod$run(times, yini) %>% as.data.frame()
result <- result %>%
pivot_longer(!t, names_to = "stage", values_to = "values") %>%
arrange(stage, t) %>%
as.data.frame()
################################################################################
ggplot(result[result$stage != "H",], aes(x = t, y = values, col = stage)) +
geom_line() +
theme_bw()
# Generate the model
mod <- pop_model$new(d_H = 0.00)
# Solve the model
result <- mod$run(times, yini) %>% as.data.frame()
result <- result %>%
pivot_longer(!t, names_to = "stage", values_to = "values") %>%
arrange(stage, t) %>%
as.data.frame()
################################################################################
ggplot(result[result$stage != "H",], aes(x = t, y = values, col = stage)) +
geom_line() +
theme_bw()
################################################################################
ggplot(result[result$stage != "",], aes(x = t, y = values, col = stage)) +
geom_line() +
theme_bw()
# Generate the model
mod <- pop_model$new(d_H = 0.00, b = 0.01)
# Solve the model
result <- mod$run(times, yini) %>% as.data.frame()
result <- result %>%
pivot_longer(!t, names_to = "stage", values_to = "values") %>%
arrange(stage, t) %>%
as.data.frame()
################################################################################
ggplot(result[result$stage != "H",], aes(x = t, y = values, col = stage)) +
geom_line() +
theme_bw()
################################################################################
ggplot(result[result$stage != "",], aes(x = t, y = values, col = stage)) +
geom_line() +
theme_bw()
# Generate the model
mod <- pop_model$new(d_H = 0.00, b = 0.005)
# Solve the model
result <- mod$run(times, yini) %>% as.data.frame()
result <- result %>%
pivot_longer(!t, names_to = "stage", values_to = "values") %>%
arrange(stage, t) %>%
as.data.frame()
################################################################################
ggplot(result[result$stage != "",], aes(x = t, y = values, col = stage)) +
geom_line() +
theme_bw()
# Generate the model
mod <- pop_model$new(d_H = 0.00, b = 0.008)
# Solve the model
result <- mod$run(times, yini) %>% as.data.frame()
result <- result %>%
pivot_longer(!t, names_to = "stage", values_to = "values") %>%
arrange(stage, t) %>%
as.data.frame()
################################################################################
ggplot(result[result$stage != "",], aes(x = t, y = values, col = stage)) +
geom_line() +
theme_bw()
# Generate the model
mod <- pop_model$new(d_H = 0.00, b = 0.009)
# Solve the model
result <- mod$run(times, yini) %>% as.data.frame()
result <- result %>%
pivot_longer(!t, names_to = "stage", values_to = "values") %>%
arrange(stage, t) %>%
as.data.frame()
################################################################################
ggplot(result[result$stage != "",], aes(x = t, y = values, col = stage)) +
geom_line() +
theme_bw()
################################################################################
ggplot(result[result$stage != "",], aes(x = t, y = values, col = stage)) +
geom_line(linewidth = 1) +
theme_bw()
################################################################################
ggplot(result[result$stage != "",], aes(x = t, y = values, col = stage)) +
geom_line(linewidth = 1) +
theme_bw(base_size = 15)
################################################################################
ggplot(result[result$stage != "",], aes(x = t, y = values, col = stage)) +
geom_line(linewidth = 1) +
theme_bw(base_size = 15) +
xlab("Time")
################################################################################
ggplot(result[result$stage != "",], aes(x = t, y = values, col = stage)) +
geom_line(linewidth = 1) +
theme_bw(base_size = 15) +
xlab("Time") +
ylab("Counts")
################################################################################
ggplot(result[result$stage != "",], aes(x = t, y = values, col = stage)) +
geom_line(linewidth = 1) +
theme_bw(base_size = 20) +
xlab("Time") +
ylab("Counts")
################################################################################
ggplot(result[result$stage != "",], aes(x = t, y = values, col = stage)) +
geom_line(linewidth = 1.5) +
theme_bw(base_size = 20) +
xlab("Time") +
ylab("Counts")
1+1
2+3
11111.1
setwd("~/Project/Viral_clearance/Influenza")
#library(conflicted)
library(rstan)
library(tidyverse)
library(kableExtra)
library(finalfit)
library(RColorBrewer)
library(lubridate)
library(brms)
library(ggplot2)
library(ggpubr)
library(scales)
library(cowplot)
library(grid)
library(webshot2)
library(webshot)
library(magick)
#conflicts_prefer(dplyr::filter)
## information on software/hardware used
version
sessionInfo()
rstan_options(auto_write = TRUE)
## parameters for the analysis
RUN_MODELS = F
my_probs = c(0.025, 0.1, .5, .9, .975)
source('functions.R')
source('priors.R')
Dmax <- c(5.5, 7.5, 14.5) # Maximum follow-up duration to be included
mITT_threshold <- 250 #Threshold for baseline viral loads to be considered mITT
use_threshold = T
Type <- c("A", "B", "All")
all_mods <-  c("Stan_models/Exponential_decay_model_basic.stan",
"Stan_models/Bi_exponential_decay_model_basic.stan",
"Stan_models/Up_and_down_model_basic.stan")
model_settings <- expand.grid(Dmax = Dmax,
mITT_threshold = mITT_threshold,
use_threshold = use_threshold,
Type = Type,
mod = all_mods)
model_settings$Niter = 2000
model_settings$Nwarmup = 1000
model_settings$Nthin = 4
model_settings$Nchain = 4
model_settings$prior = 1
model_settings$cov_matrices = 1
write.csv(model_settings, "Outputs/model_settings.csv", row.names = F)
#| echo: false
#Import data
f_name = 'Analysis_Data/no_study_drug_analysis.csv'
adastra_dat = read.csv(f_name)
adastra_dat$Rand_date = as.POSIXct(adastra_dat$Rand_date)
adastra_dat$Sex <- plyr::mapvalues(x = as.numeric(adastra_dat$Sex),
from = c(1,2),
to = c('Male','Female'))
adastra_dat$inf_diagyn <- as.factor(adastra_dat$inf_diagyn)
# Setting up the analysis
covs_base = c('symptomDay','fluType', 'Study_time', 'Age_scaled')
covs_full=c(covs_base)
model_settings
i <- 9
writeLines("Running the following job:")
print(model_settings[i,])
# Define populations by jobs
adastra_dat_i <- make_mITT(adastra_dat, model_settings$use_threshold[i], model_settings$mITT_threshold[i], model_settings$Type[i])
adastra_dat_i %>% distinct(ID, .keep_all = T) %>%
group_by(mITT, fluType) %>%
summarise(n = n(), .groups = "keep") %>%
print()
# Making analysis dataset
adastra_dat_analysis =
adastra_dat_i %>% ungroup() %>%
filter(Time <= model_settings$Dmax[i], mITT) %>%
arrange(log10_viral_load==log10_cens_vl) %>%
mutate(RnaseP_scaled = scale(40 - CT_RNaseP,scale = F),
Mean_age = mean(Age[!duplicated(ID)]),
SD_age = sd(Age[!duplicated(ID)]),
Age_scaled = (Age-Mean_age)/SD_age,
Site = as.factor(Site),
Study_time = as.numeric(difftime(Rand_date,min(Rand_date),units = 'weeks')),
Study_time = scale(Study_time)) %>%
group_by(ID, Timepoint_ID) %>%
mutate(daily_VL = mean(log10_viral_load),
daily_CT = mean(CT))
# Making baseline dataset
Baseline_data = adastra_dat_analysis %>% ungroup() %>%
filter(Timepoint_ID==0) %>%
distinct(ID, .keep_all = T) %>%
mutate(Baseline.viral.load = daily_VL,
Baseline.CT = daily_CT)
# Making Table 1: Baseline characteristics
tab.ff <- Baseline_data %>%
summary_factorlist(
dependent = "Trt", # name of grouping / treatment variable
explanatory = c("Site", "Age", 'BMI', 'weight',
'vaccine', 'inf_diagyn',
"Baseline.viral.load",'Sex', 'fluType' ,
'symptomDay'
),
total_col = TRUE, # add column with statistics for the whole sample
add_row_total = TRUE, # add column with number of valid cases
include_row_missing_col = FALSE,
add_dependent_label = T,
na_include = TRUE # make variables' missing data explicit
) %>%
kbl(
caption = "Baseline characteristics",
booktabs = TRUE,
align = "lrlrrr",
) %>%
kable_classic(full_width = FALSE)
tab.ff
