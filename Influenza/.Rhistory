mutate(
baseline_vl = mean(log10_viral_load[which(Timepoint_ID==0)]),
mITT = ifelse(use_threshold, baseline_vl > log10(mITT_threshold), T) &
all_pcr_early)
pop_table = adastra_dat %>% distinct(ID, .keep_all = T) %>% arrange(baseline_vl)
print(table(Intervention=pop_table$Trt, `mITT population` = pop_table$mITT))
table(pop_table$fluType, pop_table$mITT)
timeline <- plot_randomisation(adastra_dat %>% distinct(ID, Rand_date, Trt, fluType))
timeline
adastra_dat = adastra_dat %>% filter(mITT, fluType %in% Type) %>% group_by(ID, Timepoint_ID) %>%
mutate(daily_VL = mean(log10_viral_load),
daily_CT = mean(CT)) %>%
ungroup() %>%
mutate(Site = as.factor(Site),
Study_time = as.numeric(difftime(Rand_date,min(Rand_date),units = 'weeks')),
Study_time = scale(Study_time) #normalise
)
base_vl_plot <-  plot_vl_base(adastra_dat, fluType = T)
base_vl_plot
plot_name <- paste0('Plots/viral_dynamics_type_', Type,'.png')
png(plot_name, width = ifelse(length(Type) > 1, 8, 4), height = 4, units = 'in', res = 350)
base_vl_plot
dev.off()
#| echo: false
adastra_dat_analysis =
adastra_dat %>% ungroup() %>%
filter(Time <= Dmax, mITT) %>%
arrange(log10_viral_load==log10_cens_vl) %>%
mutate(RnaseP_scaled = scale(40 - CT_RNaseP,scale = F),
Mean_age = mean(Age[!duplicated(ID)]),
SD_age = sd(Age[!duplicated(ID)]),
Age_scaled = (Age-Mean_age)/SD_age)
Baseline_data = adastra_dat_analysis %>% ungroup() %>%
filter(Timepoint_ID==0) %>%
distinct(ID, .keep_all = T) %>%
mutate(Baseline.viral.load = daily_VL,
Baseline.CT = daily_CT)
tab.ff <- Baseline_data %>%
summary_factorlist(
dependent = "Trt", # name of grouping / treatment variable
explanatory = c("Site", "Age", 'BMI',
#'vaccine',
"Baseline.viral.load",'Sex', 'fluType' ,
'symptomDay'
),
total_col = TRUE, # add column with statistics for the whole sample
add_row_total = TRUE, # add column with number of valid cases
include_row_missing_col = FALSE,
add_dependent_label = T,
na_include = TRUE # make variables' missing data explicit
) %>%
kbl(
caption = "Baseline characteristics",
booktabs = TRUE,
align = "lrlrrr",
) %>%
kable_classic(full_width = FALSE)
tab.ff
# save_kable(tab.ff,file = 'Baseline_characteristics.png')
#| echo: false
source('priors.R')
# Analysis data
writeLines(sprintf('Analysis dataset contains %s patients and %s datapoints (%s above LLOD, %s%%)',
length(unique(adastra_dat_analysis$ID)),
nrow(adastra_dat_analysis),
sum(adastra_dat_analysis$CT<40),
round(100*mean(adastra_dat_analysis$CT<40))))
covs_base = c('symptomDay','fluType', 'Study_time', 'Age_scaled')
covs_full=c(covs_base)
stan_inputs <- list()
trt_formulas <- c("~ Trt")
for(i in 1:length(trt_formulas)){
stan_inputs[[i]] =
make_stan_inputs(input_data_fit = adastra_dat_analysis,
int_covs_base = covs_base,
int_covs_full = covs_full,
slope_covs_base = c('fluType','Study_time'),
slope_covs_full = covs_full,
#   trt_frmla = formula(trt_formulas[i]),
Dmax = Dmax)
}
all_mods = c("Stan_models/Exponential_decay_model_basic.stan",
"Stan_models/Bi_exponential_decay_model_basic.stan")
#list.files('Stan_models',full.names = TRUE,pattern = '*stan')
model_settings = expand.grid(mod = all_mods,
prior = 1,
cov_matrices = 1)
model_settings$Niter = 2000
model_settings$Nwarmup = 1000
model_settings$Nthin = 4
model_settings$Nchain = 4
writeLines(sprintf('We are running all models with %s chains and %s samples for each chain, discarding %s for burn-in and thining every %s, thus giving a total of %s posterior samples per model.',
unique(model_settings$Nchain),
unique(model_settings$Niter),
unique(model_settings$Nwarmup),
unique(model_settings$Nthin),
unique(model_settings$Nchain*(model_settings$Niter-model_settings$Nwarmup)/model_settings$Nthin)))
model_setup_f_name = paste0('Rout/model_settings_type_', Lab, '.RData')
save(model_settings,
adastra_dat_analysis,
stan_inputs,
all_priors,
file = model_setup_f_name)
i <- 1
stan_input_job = stan_inputs[[i]]
stan_input_job
i <- 2
mod = stan_model(file = as.character(model_settings$mod[i])) # compile
mod
file_name = paste0('Rout/model_fits_type_', Lab, '_',i,'.RData')
file_name
file_name = paste0('Rout/model_fits_type_', Lab, '_',i,'.RData')
save(out,
file = file_name)
out
all_priors[[model_settings$prior[i]]]
#library(conflicted)
library(rstan)
library(tidyverse)
library(kableExtra)
library(finalfit)
library(RColorBrewer)
library(lubridate)
library(brms)
library(ggplot2)
library(ggpubr)
library(scales)
library(cowplot)
library(grid)
#conflicts_prefer(dplyr::filter)
## information on software/hardware used
version
sessionInfo()
rstan_options(auto_write = TRUE)
## parameters for the analysis
Dmax = 5.5
RUN_MODELS = F
my_probs = c(0.025, 0.1, .5, .9, .975)
source('functions.R')
mITT_threshold <- 250
use_threshold = T
Type <- "A" # "A" or "B" or c("A", "B")
Lab <- ifelse(length(Type)>1, "A_and_B", Type)
#| echo: false
# set as file with relevant dataset
f_name = 'Analysis_Data/no_study_drug_analysis.csv'
adastra_dat = read.csv(f_name)
adastra_dat$Rand_date = as.POSIXct(adastra_dat$Rand_date)
# Check missing PCR data by time point
check_PCR_missing <- adastra_dat %>%
mutate(count = 1,
Timepoint_ID = paste0("D", Timepoint_ID)) %>%
group_by(ID, Timepoint_ID) %>%
summarise(n = n()) %>%
pivot_wider(names_from = Timepoint_ID, values_from = n) %>%
mutate(all_pcr_early = !is.na(sum(D0, D1, D2, D3)))
adastra_dat <- merge(adastra_dat, check_PCR_missing[,c("ID", "all_pcr_early")], all.x = T)
#| echo: false
adastra_dat = adastra_dat %>% group_by(ID) %>%
mutate(
baseline_vl = mean(log10_viral_load[which(Timepoint_ID==0)]),
mITT = ifelse(use_threshold, baseline_vl > log10(mITT_threshold), T) &
all_pcr_early)
pop_table = adastra_dat %>% distinct(ID, .keep_all = T) %>% arrange(baseline_vl)
print(table(Intervention=pop_table$Trt, `mITT population` = pop_table$mITT))
table(pop_table$fluType, pop_table$mITT)
timeline <- plot_randomisation(adastra_dat %>% distinct(ID, Rand_date, Trt, fluType))
timeline
adastra_dat = adastra_dat %>% filter(mITT, fluType %in% Type) %>% group_by(ID, Timepoint_ID) %>%
mutate(daily_VL = mean(log10_viral_load),
daily_CT = mean(CT)) %>%
ungroup() %>%
mutate(Site = as.factor(Site),
Study_time = as.numeric(difftime(Rand_date,min(Rand_date),units = 'weeks')),
Study_time = scale(Study_time) #normalise
)
base_vl_plot <-  plot_vl_base(adastra_dat, fluType = T)
base_vl_plot
plot_name <- paste0('Plots/viral_dynamics_type_', Type,'.png')
png(plot_name, width = ifelse(length(Type) > 1, 8, 4), height = 4, units = 'in', res = 350)
base_vl_plot
dev.off()
#| echo: false
adastra_dat_analysis =
adastra_dat %>% ungroup() %>%
filter(Time <= Dmax, mITT) %>%
arrange(log10_viral_load==log10_cens_vl) %>%
mutate(RnaseP_scaled = scale(40 - CT_RNaseP,scale = F),
Mean_age = mean(Age[!duplicated(ID)]),
SD_age = sd(Age[!duplicated(ID)]),
Age_scaled = (Age-Mean_age)/SD_age)
Baseline_data = adastra_dat_analysis %>% ungroup() %>%
filter(Timepoint_ID==0) %>%
distinct(ID, .keep_all = T) %>%
mutate(Baseline.viral.load = daily_VL,
Baseline.CT = daily_CT)
tab.ff <- Baseline_data %>%
summary_factorlist(
dependent = "Trt", # name of grouping / treatment variable
explanatory = c("Site", "Age", 'BMI',
#'vaccine',
"Baseline.viral.load",'Sex', 'fluType' ,
'symptomDay'
),
total_col = TRUE, # add column with statistics for the whole sample
add_row_total = TRUE, # add column with number of valid cases
include_row_missing_col = FALSE,
add_dependent_label = T,
na_include = TRUE # make variables' missing data explicit
) %>%
kbl(
caption = "Baseline characteristics",
booktabs = TRUE,
align = "lrlrrr",
) %>%
kable_classic(full_width = FALSE)
tab.ff
# save_kable(tab.ff,file = 'Baseline_characteristics.png')
#| echo: false
source('priors.R')
# Analysis data
writeLines(sprintf('Analysis dataset contains %s patients and %s datapoints (%s above LLOD, %s%%)',
length(unique(adastra_dat_analysis$ID)),
nrow(adastra_dat_analysis),
sum(adastra_dat_analysis$CT<40),
round(100*mean(adastra_dat_analysis$CT<40))))
covs_base = c('symptomDay','fluType', 'Study_time', 'Age_scaled')
covs_full=c(covs_base)
stan_inputs <- list()
trt_formulas <- c("~ Trt")
for(i in 1:length(trt_formulas)){
stan_inputs[[i]] =
make_stan_inputs(input_data_fit = adastra_dat_analysis,
int_covs_base = covs_base,
int_covs_full = covs_full,
slope_covs_base = c('fluType','Study_time'),
slope_covs_full = covs_full,
#   trt_frmla = formula(trt_formulas[i]),
Dmax = Dmax)
}
all_mods = c("Stan_models/Exponential_decay_model_basic.stan",
"Stan_models/Bi_exponential_decay_model_basic.stan")
#list.files('Stan_models',full.names = TRUE,pattern = '*stan')
model_settings = expand.grid(mod = all_mods,
prior = 1,
cov_matrices = 1)
model_settings$Niter = 2000
model_settings$Nwarmup = 1000
model_settings$Nthin = 4
model_settings$Nchain = 4
writeLines(sprintf('We are running all models with %s chains and %s samples for each chain, discarding %s for burn-in and thining every %s, thus giving a total of %s posterior samples per model.',
unique(model_settings$Nchain),
unique(model_settings$Niter),
unique(model_settings$Nwarmup),
unique(model_settings$Nthin),
unique(model_settings$Nchain*(model_settings$Niter-model_settings$Nwarmup)/model_settings$Nthin)))
model_setup_f_name = paste0('Rout/model_settings_type_', Lab, '.RData')
save(model_settings,
adastra_dat_analysis,
stan_inputs,
all_priors,
file = model_setup_f_name)
i <- 1
stan_input_job = stan_inputs[[i]]
analysis_data_stan = stan_input_job$analysis_data_stan
#analysis_data_stan$trt_mat = stan_input_job$Treatment_matrix
#analysis_data_stan$K_trt = ncol(analysis_data_stan$trt_mat)
# x_intercept = stan_input_job$cov_matrices$X_int[[model_settings$cov_matrices[i]]]
# if(ncol(x_intercept)==0) x_intercept = array(0, dim=c(nrow(x_intercept),1))
# analysis_data_stan$x_intercept = x_intercept
# analysis_data_stan$K_cov_intercept= ncol(x_intercept)
# x_slope = stan_input_job$cov_matrices$X_slope[[model_settings$cov_matrices[i]]]
# if(ncol(x_slope)==0) x_slope = array(0, dim=c(nrow(x_slope),1))
# analysis_data_stan$x_slope = x_slope
# analysis_data_stan$K_cov_slope=ncol(x_slope)
i <- 2
mod = stan_model(file = as.character(model_settings$mod[i])) # compile
all_priors[[model_settings$prior[i]]]
get_priors = function(){
prior_params = list(alpha_0_prior_mean = 5,
alpha_0_prior_sd = 2,
beta_0_prior_mean = -.5,
beta_0_prior_sd = 1,
trt_effect_sd = 1,
sigma_logvl_mean = 1,
sigma_logvl_sd = 1,
gamma_rnasep_sd = 1,
slope_coefs_sd = .5,
intercept_coefs_sd = .5,
t_max_pop_mean = -3,
t_max_pop_sd = 3,
A0_prior = 5,
B0_prior = 5,
coef_1_prior = -0.5,
coef_2_prior = -0.5,
prior_intercept_sd = 1,
prior_coef_sd = 1)
prior_params_sensitive = prior_params
for(i in grep('sd',x = names(prior_params))){
prior_params_sensitive[[i]] = prior_params_sensitive[[i]]*5
}
## we get convergence issues with the covariate models if you have very wide priors on the slope coefs
prior_params_sensitive$slope_coefs_sd=1
all_priors = list(WIP=prior_params, NIP=prior_params_sensitive)
return(all_priors)
}
all_priors=get_priors()
all_priors[[model_settings$prior[i]]]
out = sampling(mod,
data=c(analysis_data_stan,
all_priors[[model_settings$prior[i]]]),
iter=model_settings$Niter[i],
chain=model_settings$Nchain[i],
thin=model_settings$Nthin[i],
warmup=model_settings$Nwarmup[i],
save_warmup = FALSE,
seed=i,
cores = 4,
# pars=c('alpha_0', 'beta_0', 't_dof',
#        'sigma_logvl', 'sigmasq_u', 'L_Omega'), # only save trt effect parameter
include=T)
setwd("D:/Viral_clearance/Influenza")
library(rstan)
library(matrixStats)
library(doParallel)
rstan_options(auto_write = TRUE)
source('sample_size_functions.R')
source('priors.R')
# use the linear model fits for simplicity
load('Rout/model_fits_type_A_5d_job_1.RData')
# get the individual slope estimates
thetas = extract(out); rm(out)
# get the individual slope estimates
thetas = rstan::extract(out); rm(out)
thetas
my_LOD = 1
ncores = 4
options(mc.cores = ncores)
## Set up all simulation settings
Trt_effect_pos_control = 1.6
Trt_effect_neg_control = 1
trt_intervention = seq(from=1.2, to=2.0, by=.4)
trt_intervention
trt_intervention = seq(from=1.2, to=2.0, by=.2)
trt_intervention
NI_delta = log(1.6)-log(1.4)
NI_delta
Ns = seq(40,240,40)
Ns
Nsims = 100
k_slope = c(0.5, 1, 2)
sim_settings = expand.grid(N=Ns,
sim_k = 1:Nsims,
k_slope = k_slope,
k_sigma_logvl = k_sigma_logvl,
k_sigmasq_u_1 = k_sigmasq_u_1,
k_sigmasq_u_2 = k_sigmasq_u_2,
trt_effect_comp = trt_intervention,
trt_control = c(Trt_effect_pos_control,
Trt_effect_neg_control))
sim_settings
k_slope = c(0.5, 1, 2) #Varying population slopes
k_sigma_logvl = c(0.5, 1, 2) # Varying measurement errors (intra-individual variations)
k_sigmasq_u_1 = c(0.5, 1, 2) # Varying baseline viral load variations (inter-individual variations)
k_sigmasq_u_2 = c(0.5, 1, 2) # Varying slope variations (inter-individual variations)
sim_settings = expand.grid(N=Ns,
sim_k = 1:Nsims,
k_slope = k_slope,
k_sigma_logvl = k_sigma_logvl,
k_sigmasq_u_1 = k_sigmasq_u_1,
k_sigmasq_u_2 = k_sigmasq_u_2,
trt_effect_comp = trt_intervention,
trt_control = c(Trt_effect_pos_control,
Trt_effect_neg_control))
sim_settings
Nsims = 50
k_slope = c(0.5, 1, 2) #Varying population slopes
k_sigma_logvl = c(0.5, 1, 2) # Varying measurement errors (intra-individual variations)
k_sigmasq_u_1 = c(0.5, 1, 2) # Varying baseline viral load variations (inter-individual variations)
k_sigmasq_u_2 = c(0.5, 1, 2) # Varying slope variations (inter-individual variations)
sim_settings = expand.grid(N=Ns,
sim_k = 1:Nsims,
k_slope = k_slope,
k_sigma_logvl = k_sigma_logvl,
k_sigmasq_u_1 = k_sigmasq_u_1,
k_sigmasq_u_2 = k_sigmasq_u_2,
trt_effect_comp = trt_intervention,
trt_control = c(Trt_effect_pos_control,
Trt_effect_neg_control))
sim_settings
Nsims = 100
k_slope = c(0.5, 1, 2) #Varying population slopes
k_sigma_logvl = c(0.5, 1, 2) # Varying measurement errors (intra-individual variations)
k_sigmasq_u_1 = c(0.5, 1, 2) # Varying baseline viral load variations (inter-individual variations)
k_sigmasq_u_2 = c(0.5, 1, 2) # Varying slope variations (inter-individual variations)
sim_settings = expand.grid(N=Ns,
sim_k = 1:Nsims,
k_slope = k_slope,
k_sigma_logvl = k_sigma_logvl,
k_sigmasq_u_1 = k_sigmasq_u_1,
k_sigmasq_u_2 = k_sigmasq_u_2,
trt_effect_comp = trt_intervention,
trt_control = c(Trt_effect_pos_control,
Trt_effect_neg_control))
sim_settings
save(sim_settings, file = 'Rout/sim_settings.RData')
### set up simulation for the settings i
print(sim_settings[i, ])
trt_effects = c(sim_settings$trt_control[i],
sim_settings$trt_effect_comp[i])
Trt_vector = c(rep(1, sim_settings$N[i]),
rep(2, sim_settings$N[i]))
trt_effects
Trt_vector
# simulate data
sim_vl = sim_individuals(thetas = thetas,
t_design = rep(0:5,2),
N = length(Trt_vector),
trt_effects = trt_effects,
Trt_arm = Trt_vector,
LOD = my_LOD,
f_sim = f_sim)
sim_vl
sim_vl$Trt = factor(sim_vl$Trt_arm,levels=1:2)
sim_vl$Censored = as.numeric(sim_vl$log10_viral_load==sim_vl$log10_cens_vl)
sim_vl = dplyr::arrange(sim_vl, Censored, ID)
analysis_data=make_stan_inputs(input_data_fit = sim_vl,
trt_frmla = as.formula('~Trt'),
Dmax = 5.5)
analysis_data
# fit model to simulated data
mod = stan_model(file = 'Linear_model_basic.stan') # compile
# fit model to simulated data
mod = stan_model(file = 'Stan_models/Linear_model_basic.stan') # compile
stan_out = sampling(mod,
data=c(analysis_data,
all_priors[['WIP']]),
iter=2000,
chain=4,
thin=4,
warmup=1000,
save_warmup = FALSE,
pars=c('trt_effect'),
include=T, verbose=F)
thetas
sim_settings$k_slope[i]
thetas$sigmasq_u
nrow(model_settings)
nrow(sim_settings)
sim_settings
## Set up all simulation settings
Trt_effect_pos_control = 1.6
Trt_effect_neg_control = 1
trt_intervention = seq(from=1.2, to=2.0, by=.2)
#NI_delta = log(1.6)-log(1.4)
Ns = seq(40,240,40)
Nsims = 50
#Basic
k_slope = c(1, 2) #Varying population slopes
k_sigma_logvl = c(1, 2) # Varying measurement errors (intra-individual variations)
k_sigmasq_u_1 = c(1, 2) # Varying baseline viral load variations (inter-individual variations)
k_sigmasq_u_2 = c(1, 2) # Varying slope variations (inter-individual variations)
sim_settings = expand.grid(N=Ns,
sim_k = 1:Nsims,
k_slope = k_slope,
k_sigma_logvl = k_sigma_logvl,
k_sigmasq_u_1 = k_sigmasq_u_1,
k_sigmasq_u_2 = k_sigmasq_u_2,
trt_effect_comp = trt_intervention,
trt_control = c(Trt_effect_pos_control,
Trt_effect_neg_control))
sim_settings
Ns = seq(40,240,40)
Nsims = 100
#Basic
k_slope = c(1, 2) #Varying population slopes
k_sigma_logvl = c(1, 2) # Varying measurement errors (intra-individual variations)
k_sigmasq_u_1 = c(1, 2) # Varying baseline viral load variations (inter-individual variations)
k_sigmasq_u_2 = c(1, 2) # Varying slope variations (inter-individual variations)
sim_settings = expand.grid(N=Ns,
sim_k = 1:Nsims,
k_slope = k_slope,
k_sigma_logvl = k_sigma_logvl,
k_sigmasq_u_1 = k_sigmasq_u_1,
k_sigmasq_u_2 = k_sigmasq_u_2,
trt_effect_comp = trt_intervention,
trt_control = c(Trt_effect_pos_control,
Trt_effect_neg_control))
sim_settings
sim_settings
## Set up all simulation settings
Trt_effect_pos_control = 1.6
Trt_effect_neg_control = 1
trt_intervention = seq(from=1.2, to=2.0, by=.2)
#NI_delta = log(1.6)-log(1.4)
Ns = seq(40,240,40)
Nsims = 100
#Basic
k_slope = c(1) #Varying population slopes
k_sigma_logvl = c(1) # Varying measurement errors (intra-individual variations)
k_sigmasq_u_1 = c(1) # Varying baseline viral load variations (inter-individual variations)
k_sigmasq_u_2 = c(1) # Varying slope variations (inter-individual variations)
sim_settings = expand.grid(N=Ns,
sim_k = 1:Nsims,
k_slope = k_slope,
k_sigma_logvl = k_sigma_logvl,
k_sigmasq_u_1 = k_sigmasq_u_1,
k_sigmasq_u_2 = k_sigmasq_u_2,
trt_effect_comp = trt_intervention,
trt_control = c(Trt_effect_pos_control,
Trt_effect_neg_control))
sim_settings
